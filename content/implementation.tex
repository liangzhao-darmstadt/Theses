\chapter{Implementaion}
\label{cha:implementations}


\section{Implementations Details}
\label{sec:implementationsdetails}

In this section, we introduce the implementation details of the differentially private mechanisms (cf.) described in the previous section. A technical challenge is to identify the most efficient implementations among the SMPC schemes (cf.). We implemente both fixed-point and floating-point arithmetic, that are based on LSSS (ref.) and GBmw(ref.). After the benchmarking, we finally choose LSSS-based fixed-point and LSSS-based floating-point arithmetic as the number representation for our differentially private mechanism. 

\textbf{bgmw signed integer arithemtic}
except (unsigned integer), we also implemente signed integer arithmetic that support conversion with bgmw fixed-point and bgmw floating-point. The circuit is generate with HyCC. 


\textbf{LSSS fixed-point arithmetic implementation}
For fixed-point form, each real value is repsesente as a double () , details and reference. For exp, we use polynomial form from ref. to approximate 

\textbf{LSSS floating-point arithmetic implementation}
For floating-point form, each real value is representa as a quadruple, ??? details.
128-bit number
??? ref protocol, modification. The work by ref. provides the MPC protocols for exp2, and ,,,,
convert exp with. 
work by ref works on prime field, which can compute inverse of elements,
But MOTION support arithemtic under 2^n, we use protocols from (ref. ) to replace the steps that involves computation of the inverse of elements. More specifically, ??? , right shift, 



\textbf{bgmw fixed-point arithmetic implementation}
48 integer bits, and 16 fraction bits. (? why choose so)
We use CBMC-2.0 to genreate the necessary circuit for bgmw fixed-point arithmetic. For operations like sqrt, we use the same polynomial as to approximate and generate correspond circuits. 


\textbf{bgmw floating-point arithmetic implementation}
For operation like exp, sqrt, we use circuit from (ref. aby). 
For operation like convert between, we generate circuit with CBMC-2.0 for (c library).



\textbf{benchmark of different number representation and protocols}
table, benchmark result, between the LSSS-based fixed-point, floating-point and bgmw fixed-point arithmetic and floating-point arithmetic. 

From benchmark result above, it can be seen that the LSSS-based arithmetic is an order of magnitude slower that bgmw arithmetic. Therefore, we finally choose bgmw arithemtic to implemente the differentially private mechanisms. 










